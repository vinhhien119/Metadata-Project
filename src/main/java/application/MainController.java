package application;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * This program handles HTTP requests to the application, specifically POST and GET.
 *
 * @author Jay Bryant (https://spring.io/guides/gs/accessing-data-mysql/)
 * @author Sarah Haines
 * @author Romina Petrozzi
 * @author Yusur Taha
 * @author Kyle Piazza-Nickson
 */
@Controller // This means that this class is a Controller
public class MainController {

  @Autowired // This gets the bean called assetRepository
  // Which is auto-generated by Spring and handles the data
  private AssetRepository assetRepository;

  @Autowired // This gets the bean called typeRepository
  private TypeRepository typeRepository;

  @Autowired // This gets the bean called actionLogRepository
  private ActionLogRepository actionLogRepository;

  @Autowired
  private AssetCommentRepository assetCommentRepository;

  @Autowired
  public MainController(AssetRepository assetRepository) {
    this.assetRepository = assetRepository;
  }

  public MainController(AssetRepository assetRepository, ActionLogRepository actionLogRepository) {
    this.assetRepository = assetRepository;
    this.actionLogRepository = actionLogRepository;
  }

  /**
   * This method allows for the application of CORS cross origin compatibility with the API.
   */
  @RequestMapping(value = "/products")
  @CrossOrigin(origins = "http://localhost:8080")
  public ResponseEntity<Object> getProduct() {
    return null;
  }

  // Start of asset functions

  /**
   * This method is a map only for POST requests. It takes the parameters supplied by the user for
   * the asset and inputs it into the database.
   *
   * @return confirmation string
   */
  @PostMapping(path = "/asset/add", consumes = "application/json")
  // Map ONLY POST Requests and consume JSON
  public ResponseEntity<String> addNewAsset(@RequestBody Asset asset) {
    try {
      // Check if an asset with the same title already exists
      if (assetRepository.existsByTitle(asset.getTitle())) {
          // Asset with the same title already exists, return a conflict status
          return ResponseEntity.status(HttpStatus.CONFLICT).body("An asset with the same title already exists");
      }

      // Save the asset to the database
      assetRepository.save(asset);
      addActionLog(asset.getId(), null, "Added asset"); // Adds an action record to the log
      return ResponseEntity.ok("Asset saved successfully");
  } catch (Exception e) {
      e.printStackTrace();
      return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error: " + e.getMessage());
  }

  }


  /**
   * This method fetches all the assets stored in the database and returns a JSON file of the
   * content to the web page.
   *
   * @return all assets and their attributes
   */
  @GetMapping(path = "/asset/find/all")
  public @ResponseBody Iterable<Asset> getAllAssets() {
    // This returns a JSON or XML with the assets
    return assetRepository.findAll();
  }

  /**
   * This method is a query function to request the details of an asset by its Id number in the url
   * localhost:8080/asset/find/{id}.
   *
   * @param id of the asset to be queried
   * @return JSON of the asset returned by the id number search
   */
  @GetMapping(path = "/asset/find/{id}")
  public @ResponseBody Optional<Asset> getAssetById(@PathVariable("id") Integer id) {
    // This returns a JSON or XML with the assets
    return assetRepository.findById(id);
  }

  /**
   * This method allows for the deletion of individual assets by referencing their id numbers in the
   * url localhost:8080/asset/delete/{id}.
   *
   * @param id of the asset to be deleted
   * @return onward path routing for the resultDeleteAsset.html page
   */
  @RequestMapping(value = "/asset/delete/{id}", method = {RequestMethod.DELETE, RequestMethod.GET})
  public String deleteAsset(@PathVariable("id") Integer id) {
    assetRepository.deleteById(id);
    addActionLog(id, null, "Deleted asset"); // Adds an action record to the log
    return "resultDeleteAsset";
  }

  /**
   * This method checks whether a given asset by the same name and type already exists in the
   * database.
   * 
   * @param assetName of asset
   * @param typeName of asset
   * @return boolean depending on whether the asset exists
   */
  @GetMapping(path = "/asset/getAssetExists/{title}/{type}")
  public @ResponseBody Boolean getAssetExists(@PathVariable("title") String assetName,
      @PathVariable("type") String typeName) {
    List<Asset> assetList = getAssetByTitle(assetName);
    if (assetList.size() > 0) {
      for (Asset i : assetList) {
        if (i.getType().equalsIgnoreCase(typeName)) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * This method is a query function to request the details of assets by their title in the url
   * localhost:8080/asset/findTitle/{title}.
   *
   * @return asset list that has assets of the same title as the searched title
   */
  @GetMapping(path = "/asset/findTitle/{title}")
  public @ResponseBody List<Asset> getAssetByTitle(@PathVariable("title") String title) {
    List<Asset> assetsWithTitle = new ArrayList<>();
    // find collection of assets which can be iterated over
    Iterable<Asset> allAssets = assetRepository.findAll();
    for (Asset asset : allAssets) { // look through collection of assets
      if (asset.getTitle().equals(title)) {
        assetsWithTitle.add(asset);
      }
    }
    return assetsWithTitle;
  }

  /**
   * This method is a query function to request the details of assets by their type in the url
   * localhost:8080/asset/findType/{type}.
   *
   * @param type of asset user wants
   * @return asset list that has assets of the same type as the searched type
   */
  @GetMapping(path = "/asset/findType/{type}")
  public @ResponseBody List<Asset> getAssetByType(@PathVariable("type") String type) {
    List<Asset> assetsWithType = new ArrayList<>();

    Iterable<Asset> allAssets = assetRepository.findAll();
    for (Asset asset : allAssets) {
      if (asset.getType().equals(type)) {
        assetsWithType.add(asset);
      }
    }
    return assetsWithType;
  }

  /**
   * This method is a query function to request the details of assets by their link in the url
   * localhost:8080/asset/findLink/{link}.
   *
   * @param link of asset that user wants
   * @return asset that has same link as the searched link
   */
  @GetMapping(path = "/asset/findLink/{link}")
  public @ResponseBody List<Asset> getAssetByLink(@PathVariable("link") String link) {
    List<Asset> assetsWithLink = new ArrayList<>();

    Iterable<Asset> allAssets = assetRepository.findAll();
    for (Asset asset : allAssets) {
      if (asset.getLink().equals(link)) {
        assetsWithLink.add(asset);
      }
    }
    return assetsWithLink;
  }

  /**
   * This method is a query function to request the details of assets by their author in the url
   * localhost:8080/asset/findAuthor/{author}.
   *
   * @param author of asset that user wants
   * @return asset that has same author as the searched author
   */
  @GetMapping(path = "/asset/findAuthor/{author}")
  public @ResponseBody List<Asset> getAssetByAuthor(@PathVariable("author") String author) {
    List<Asset> assetsWithAuthor = new ArrayList<>();

    Iterable<Asset> allAssets = assetRepository.findAll();
    for (Asset asset : allAssets) {
      if (asset.getAuthor().equals(author)) {
        assetsWithAuthor.add(asset);
      }
    }
    return assetsWithAuthor;
  }


  //// End of Asset functions. Start of Type functions.


  /**
   * Post request to fetch type data from UI form and add it to the database.
   * 
   * @param type type object to submit
   * @return response entity depending on outcome
   */
  @PostMapping(path = "/type/add", consumes = "application/json")
  public ResponseEntity<String> addNewType(@RequestBody Type type) {
    try {
      typeRepository.save(type);
      addActionLog(null, type.getId(), "Added type"); // Adds an action record to the log
      return ResponseEntity.ok("Type saved successfully");
    } catch (Exception e) {
      e.printStackTrace();
      return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
          .body("Error: " + e.getMessage());
    }
  }

  /**
   * Path to add types to the database using parameters. Used by loading scripts.
   * 
   * @param type name of type
   * @param customAttribute1 type attribute
   * @param customAttribute2 type attribute
   * @param customAttribute3 type attribute
   * @param customAttribute4 type attribute
   * @return confirmation string
   */
  @PostMapping(path = "/type/add") // Map ONLY POST Requests
  public @ResponseBody String addNewType(@RequestParam String type,
      @RequestParam String customAttribute1, @RequestParam String customAttribute2,
      @RequestParam String customAttribute3, @RequestParam String customAttribute4) {
    // @ResponseBody means the returned String is the response, not a view name
    // @RequestParam means it is a parameter from the GET or POST request

    Type t = new Type();
    t.setTypeName(type);
    t.setCustomAttribute1(customAttribute1);
    t.setCustomAttribute2(customAttribute2);
    t.setCustomAttribute3(customAttribute3);
    t.setCustomAttribute4(customAttribute4);
    typeRepository.save(t);
    return "Saved";
  }

  /**
   * This method fetches all the types stored in the database and returns a JSON file of the content
   * to the web page.
   *
   * @return all types and their custom attributes
   */
  @GetMapping(path = "/type/find/all")
  public @ResponseBody Iterable<Type> getAllTypes() {
    // This returns a JSON or XML with the assets
    return typeRepository.findAll();
  }

  /**
   * This method is a query function to request the details of a type by its Id number in the url
   * localhost:8080/type/find/{id}.
   *
   * @param id of the type to be queried
   * @return JSON of the type returned by the id number search
   */
  @GetMapping(path = "/type/find/{id}")
  public @ResponseBody Optional<Type> getTypeById(@PathVariable("id") Integer id) {
    // This returns a JSON or XML with the assets
    return typeRepository.findById(id);
  }

  /**
   * This method is a query function to request the details of a type by its name in the url
   * localhost:8080/type/find/{typeName}.
   *
   * @param typeName of the type to be queried
   * @return JSON of the type returned by the name search
   */
  @GetMapping(path = "/type/findName/{typeName}")
  public @ResponseBody Optional<Type> getTypeByName(@PathVariable("typeName") String typeName) {
    // This returns a JSON or XML with the assets
    return typeRepository.findByTypeName(typeName);
  }

  /**
   * This method checks whether a given type by the same name already exists in the database.
   *
   * @param typeName name of type
   * @return boolean depending on whether the type exists
   */
  @GetMapping(path = "/type/getTypeExists/{typeName}")
  public @ResponseBody Boolean getTypeExists(@PathVariable("typeName") String typeName) {
    Optional<Type> optType = getTypeByName(typeName);
    return (optType.isPresent());
  }

  /**
   * This method allows for the deletion of individual types and corresponding assets by referencing
   * their id numbers in the url localhost:8080/type/delete/{id}.
   *
   * @param id of the type to be deleted
   * @return confirmation string
   */
  @RequestMapping(value = "/type/delete/{id}", method = {RequestMethod.DELETE, RequestMethod.GET})
  public String deleteType(@PathVariable("id") Integer id) {
    Optional<Type> typeOptional = typeRepository.findById(id);
    if (!typeOptional.isPresent()) {
      // Handle case where type with the provided id doesn't exist
      return "Type not found";
    }
    Type typeToDelete = typeOptional.get();

    // Find all assets with matching type name
    List<Asset> assetsToDelete = assetRepository.findByType(typeToDelete.getTypeName());
    for (Asset asset : assetsToDelete) {
      // Delete each associated asset
      assetRepository.delete(asset);
      // Add an action record to the log for each deleted asset
      addActionLog(asset.getId(), null, "Deleted asset");
    }

    // Delete the type itself
    typeRepository.deleteById(id);
    addActionLog(null, id, "Deleted type"); // Add an action record to the log for the deleted type

    return "Type deleted";
  }

  //// End of Type functions. Start of Log functions.

  /**
   * This method is a map only for POST requests, It takes the parameters for the action log and
   * inputs it in to the database.
   * 
   * @param assetId reference id for the asset being recorded in the log
   * @param typeId reference id for the type being recorded in the log
   * @param action what task was being undertaken on that item id (such as: deleted)
   * @return confirmation string
   */
  public @ResponseBody String addActionLog(@RequestParam Integer assetId,
      @RequestParam Integer typeId, @RequestParam String action) {

    LocalDateTime now = LocalDateTime.now();
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

    ActionLog al = new ActionLog();
    al.setAssetId(assetId);
    al.setTypeId(typeId);
    al.setAction(action);
    al.setTimestamp(now.format(formatter));
    actionLogRepository.save(al);
    return "Saved";
  }

  /**
   * This method fetches all the action logs stored in the database and returns a JSON file of the
   * content to the web page.
   *
   * @return all the action logs and their details
   */
  @GetMapping(path = "/log/find/all")
  public @ResponseBody Iterable<ActionLog> getAllLog() {
    // This returns a JSON or XML with the assets
    return actionLogRepository.findAll();
  }

  /**
   * This method is a query function to request the details of an asset by its Id number in the url
   * localhost:8080/asset/find/{id}.
   *
   * @param id of the log entry to be queried
   * @return JSON of the action log to be returned by the id number search
   */
  @GetMapping(path = "/log/find/{id}")
  public @ResponseBody Optional<ActionLog> getLogById(@PathVariable("id") Integer id) {
    // This returns a JSON or XML with the assets
    return actionLogRepository.findById(id);
  }

  //// End of log functions, Start of Comment functions.

  /**
   * This method fetches all the asset comments stored in the database and returns a JSON file of
   * the content to the web page.
   *
   * @return all the asset comments and their details
   */
  @GetMapping(path = "/comment/find/all")
  public @ResponseBody Iterable<AssetComment> getAllComment() {
    // This returns a JSON or XML with the comments
    return assetCommentRepository.findAll();
  }

  /**
   * This method is a query function to request the details of an asset by its Id number in the url
   * localhost:8080/comment/find/{id}.
   *
   * @param id of the comment entry to be queried
   * @return JSON of the asset comment to be returned by the id number search
   */
  @GetMapping(path = "/comment/find/{id}")
  public @ResponseBody Optional<AssetComment> getCommentById(@PathVariable("id") Integer id) {
    // This returns a JSON or XML with the comments
    return assetCommentRepository.findById(id);
  }

  /**
   * Post request to fetch comment data from UI form and add it to the database.
   * 
   * @param comment from user
   * @return response entity depending on outcome
   */
  @PostMapping(path = "/comment/add", consumes = "application/json")
  public ResponseEntity<String> addNewComment(@RequestBody AssetComment comment) {
    try {
      assetCommentRepository.save(comment);
      addActionLog(comment.getItemId(), null, "Added comment"); // Adds an action record to the log
      return ResponseEntity.ok("Comment saved successfully");
    } catch (Exception e) {
      e.printStackTrace();
      return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
          .body("Error: " + e.getMessage());
    }
  }
}
